syntax = "proto3";

package itcoin.transport;

import "google/protobuf/empty.proto";
import "pbft.proto";

/*
 * Defines the gRPC TransportService, which is used by itcoin::transport::Ipc.
 */

enum Role {
  INVALID = 0;
  REPLICA = 1;
  CLIENT = 2;
}

message PeerIdentifier {
  Role role = 1;
  uint32 id = 2;
}

message PayloadType {
  itcoin.pbft.MessageTag tag = 1;
}

message SignedMessage {
  /*
   * This field symbolically identifies the sender party that claims to have
   * sent this message.
   *
   * In practice, this field is used by the receiver to select the key to use
   * when validating the message signature.
   */
   PeerIdentifier sender = 1;

  /*
   * The type of the message the binary payload is supposed to be decoded to.
   * This field is authenticated by the "signature" field.
   */
  PayloadType payloadType = 2;

  /*
   * protobuf-serialized representation of the payload.
   *
   * The actual type of the payload must be deduced from the payloadType field.
   *
   * In order to get the unmarshalled C++ object, the function
   * ParseFromString(const string& data) can be called.
   *
   * Please note that in this case std::string is not a string in the literal
   * sense: "Note that the bytes are binary, not text; we only use the string
   * class as a convenient container."
   *
   * source: https://developers.google.com/protocol-buffers/docs/cpptutorial#parsing-and-serialization
   */
  bytes payload = 3;

  /*
   * A signature for the payload and the payloadType field, done using the
   * private key identified by "sender".
   *
   * The signature is performed by the bitcoind instance residing on the
   * "sender" server, invoking its JSON-RPC interface on method
   * signmessage(f(sender), digest). The resulting contents is stored
   * as-is, and is thus a base64-encoded string, 88 ascii characters in lenght,
   * that encodes 65 bytes.
   *
   * The signature is performed on a message digest computed as follows:
   *
   * digest = sha256sum(proto3encode(payloadType) + payload)
   *
   * Where:
   * - "+" means binary concatenation
   * - sha256sum() gives its result as a hex-encoded string (i.e.: "AB" becomes
   *   "4142"
   * - for simplicity, proto3encode() is assumed to be deterministic, and to
   *   always give the same result for all the executions and all the
   *   implementation languages. This is more or less true as long as
   *   PayloadType wraps a simple enum, but proto3 offers no provisions for a
   *   canonical representation of a message.
   *
   *   Tests enforce (after-the-fact, due to protobuf3 limitations) that a
   *   PayloadType serializes deterministically.
   */
  bytes signature = 4;

  /*
   * Optional field, not covered by any signature, that may contain a raw
   * protobuf-encoded message. PBFT uses this field only when sending the
   * PrePrepareMessage, in order to broadcast the RequestMessage the primary
   * received from a client.
   */
  bytes piggybackedData = 5;
}

service TransportService {
  rpc AcceptSignedMessage(SignedMessage) returns (google.protobuf.Empty);
}
